= One Assertion Per Test

|===
|Term               | Abbreviation
|Subject Under Test | SUT
|===

The purpose of this document is to explore the motivations behind the rule _One Assertion Per Test_ and describe the benefits of its practice.

_One Assertion Per Test_ is a heuritstic which can identify poorly-designed interfaces. When writing tests, the egnineer strives to write their test cases such that each contains only one assertion about the SUT's behaviour. When the engineer encounters difficulty in this practice, it is a warning that the SUT's API is poorly designed.

As a heuristic, there are situations in which dogmatically adhering to this rule is not productive, but an engineer should be objective when claiming this exception. Consider for example the scenario in which an engineer is adding unit tests to a poorly-covered unit of legacy software. Having difficulty adhering to the rule, the engineer confirms though careful analysis that the SUT has a poorly-designed API (note that this analysis does not depend soley on the heuristic itself). The engineer then weighs the value of fixing that API against the cost of re-writing code coupled to it. They determine that the cost is too great; in this case the engineer is justified in deviating from the rule. Note that the engineer has learned from the experience, which is essential for that justification. In many situations, the engineer will discover that the problem lies in their freshly-written code and should be fixed. The difference can only be understood through dilligence.

== When multiple assertions indicate a flawed API

Consider the following psudocode test case:

[source]
----
  expected_friend_1 = ...
  expected_friend_2 = ...

  friends_list = user.get_friends()

  assert friends_list.contains?(expected_friend_1)
  assert friends_list.contains?(expected_friend_2)
----

Why are there multiple assertions in this test case? The engineer tried initially to verify the contents of the list using a direct comparison: `assert friends_list == [ expected_friend_1, expected_friend_2 ]`. This was brittle, they discovered, because the order of the friends in the list was inconsistent. They resolved this problem by checking instead if each friend was a member of the list, but not their position in it.

How does this indicate a flaw in the API? With the assumption that no friend appears in the list more than once, the added realization that their order is irrelevant leads us to conlude that this collection of friends is not a list, but a _set_. The engineer could update the API to return a set of friends instead, resulting in the following code:

[source]
----
  expected_friend_1 = ...
  expected_friend_2 = ...

  friends_set = user.get_friends()

  assert friends_set == Set.of(expected_friend_1, expected_friend_2)
----

This change to the API better reflects the essence of the problem that the SUT seeks to solve. The solution using a list made assumptions about the ordering and uniqueness of friends that are irrelevant to the problem.

NOTE: The original test case illustrates _accidental complexity_, complexity which arises as a consequence of a chosen solution instead of as a consequence of the problem itself; complexity which is not _essential_ to solve the problem correctly. (See _Code Complete, 2nd Ed._ by Steve McConnell, p. 77: "Accidental and Essential Difficulties".) Identification of such complexity reduces the difficulty in maintaining a software solution long-term.

=== A corrolary to the Single Responsibility Principle

When multiple assertions are necessary to describe the behavior of the SUT, we may infer that the SUT has too many responsibilities, which is a kind of API flaw. Since the test struggles to isolate a single behavior of the SUT, other client code will similarly struggle to exercise that behavior. Such a SUT is inflexible and cannot be used for purposes beyond the original author's limited perspective.

_Objects and functions with limited responsibilities are trivial to compose into larger orchestrations and for new purposes. Monolithic objects and functions are seldom re-usable because they make too many assumptions about how they will be used._

== When the test case is itself flawed

It is possible to violate the rule simply by testing too many aspects of the SUT at once. This forces future readers to mentally pick the test apart in order to determine which behaviors contribute to which consequences under test. This undermines the value of the test as documentation and guarantees that it will degrade over time as engineers make haphazard changes to it.

_A test which fails for exactly one reason is easy to comprehend and maintain, whereas a test which fails for many is likely to become a burdon._
